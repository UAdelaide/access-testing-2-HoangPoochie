When modeling relationships between tables, it is critical to place the foreign key in the table that represents the “many” side of a one-to-many relationship (or in the appropriate junction table for a many-to-many). In our textbook marketplace schema, for example, each Listing belongs to exactly one User (the seller), and each User may create many Listings. Placing the foreign key seller_id in the Listings table accurately captures that cardinality: every listing row carries a reference to its owning user. Had we placed a listing_id column in the Users table instead, we would wrongly imply that each user can be tied to only one listing, or force us to update or duplicate user rows for additional listings—neither of which correctly reflects the real-world scenario.

Correct foreign key placement also supports normalization principles. First, by ensuring that the Listings table holds only one atomic reference to a single user’s ID, we obey First Normal Form: no column holds a list or repeating group of IDs. Second, because Listings has a single-column primary key (listing_id), every non-key attribute in Listings (such as price, posted date, or status) depends on that listing_id, so we satisfy Second Normal Form without risk of partial dependencies. Third, in Third Normal Form, non-key attributes must not depend transitively on other non-key attributes. By storing only the user’s ID in Listings and not duplicating user attributes (such as email or username) in that table, we avoid a scenario where, say, seller_email in Listings would depend on seller_id. Instead, any needed user details can be retrieved by joining back to Users, thus preventing redundant storage and transitive dependencies.

If the foreign key were placed incorrectly—for instance, if we added a column seller_id in the Books table to represent who is selling an ISBN—we would inadvertently restrict each book record to a single seller. That would force us either to overwrite the book row each time another student wants to sell the same textbook edition (losing the previous seller’s data) or to create duplicate book rows with identical title/author/ISBN information, leading to redundancy and update anomalies. Similarly, if we tried to record a purchase by placing a buyer_id column in Books, we would misrepresent the real-world: a textbook edition can be listed and sold many times by different users over time, not just once. These misplaced foreign keys break normalization and cause difficulty enforcing referential integrity, because the parent-child relationships become muddled or too restrictive.

When foreign keys are correctly placed, the database can enforce referential integrity straightforwardly: the database ensures that any seller_id or buyer_id in Listings corresponds to an existing Users row; if a user is deleted (depending on cascade rules), we can handle related listings in a consistent manner. Incorrect placement can lead to insertion anomalies (e.g., not being able to insert a listing because the wrong parent row doesn’t yet exist or because the parent would need to be updated each time), deletion anomalies (orphaned rows left behind), and update anomalies (duplicated data needing multiple updates).

In practice, one explains this in a report by first stating the relationship: “A User may create many Listings, but each Listing is associated with exactly one User,” and then noting that the foreign key resides in the Listings table. One then ties this to normalization, explaining that Listings stores only the user’s ID (not user attributes), so all its other columns depend solely on the listing’s primary key and not on another non-key attribute, thereby satisfying 3NF. To illustrate what goes wrong, one can describe a hypothetical alternative where Book or User tables held the foreign key, and show how that either restricts valid cases (preventing multiple sellers for the same ISBN) or introduces redundancy and anomalies. Emphasizing that correct foreign key placement aligns with both accurate real-world modeling and the avoidance of redundancy or transitive dependencies will make a convincing normalization argument.